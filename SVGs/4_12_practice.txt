[standard heading w tei declaration]    
    Was late to class
declare variable $plays as document-node()+ := collection("/db/apps/shakespeare/data");
    Every statement that starts with declare must end w a semicolon
    This is equal to a let variable
    Declarations have to go at the top = global variable, completely the same as a let
declare variable $speakers := distinct-values($plays//tei:speaker);
    Take all 43 plays and find all of their speakers and get rid of their duplicates
    distinct-values automatically turns nodes (//speaker) into strings (or numbers)
    Now we want to loop over the speakers and find how many plays they occur in
for $speaker in $speakers
    starting a for loop (will require a return)
return $speaker
    Find the plays that the speaker name occurs in and count them
    $plays [descendant::tei:speaker = $speaker] the human way to say (something) this is general equality, 100s of things equal one thing; is anything in descendant::tei:speaker equal to $speaker
    The problem with this ^ is exide doesn't like it; theres an awful lot of computation and exide has trouble optimizing it and therefore it will be very slow
let $myPlays := $plays//tei:speaker[. = $speaker]/ancestor::tei:TEI
    The plays I'm interested in at the moment that contain this speaker
    Instead of finding the plays and filtering them, for all the plays get all their speaker elements and wherever there is a speaker element that is equal to the speaker element we care about at the moment, go up to it's root element
    This is faster than the preceding solution which was more elegant
    test with return count($myPlays)
    this comes back quickly and gives different values so thats good
let $playCount := count($myPlays)
let $playTitles := string-join($myPlays//tei:titleStmt/tei:title, "; ")
    $myPlays = the plays in which the speakers occurs, this will get the titles 
    string-join turns the titles into a list using the "; " seperator
    using a semicolon just in case any of the titles contain commas
    
    insert nested FLOWR expression below
        let$playTitles:=
            let $unsortedTitles := $myPlays//tei:titleStmt/tei:title
            for $unsortedTitle in $unsortedTitles
            order by $unsortedTitle
            return $unsortedTitle 
      
where $playCount gt 10
    this filters the result
order by $playCount descending
    this returns the list so the character in the most plays appears first
return concat($speaker, " appears in ", $playCount, " plays: ", string-join($playTitles, ";"))
    This returns the speaker appears in however many plays which are whatever list of titles
    You can only return one thing, so concat is used to join together the parts, similar to string-join
    Gonna use a nested FLOWR expression to sort plays 
    The string-join on $playTitles is only necessary if you use the nexted FLOWR expression
    
    The main take away: in the first for speaker we have to loop over the speakers; you can't start by looping over the plays